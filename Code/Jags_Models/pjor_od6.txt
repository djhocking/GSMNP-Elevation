
    model{
    # Priors
    alpha.lam ~ dnorm(0, 0.01)
    beta1.lam ~ dnorm(0, 0.01)
    beta2.lam ~ dnorm(0, 0.01)
    beta3.lam ~ dnorm(0, 0.01)
    # beta4.lam ~ dnorm(0, 0.01)
    # beta5.lam ~ dnorm(0, 0.01)
    # beta6.lam ~ dnorm(0, 0.01)
    # beta7.lam ~ dnorm(0, 0.01)
    beta8.lam ~ dnorm(0, 0.01)
    beta9.lam ~ dnorm(0, 0.01)
    # beta10.lam ~ dnorm(0, 0.01)
    # beta11.lam ~ dnorm(0, 0.01)
    beta12.lam ~ dnorm(0, 0.01)
    # beta13.lam ~ dnorm(0, 0.01)
    
    alpha.p ~ dnorm(0, 0.01)
    beta1.p ~ dnorm(0, 0.01)
    beta2.p ~ dnorm(0, 0.01)
    beta3.p ~ dnorm(0, 0.01)
    beta4.p ~ dnorm(0, 0.01)
    beta5.p ~ dnorm(0, 0.01)
    beta10.p ~ dnorm(0, 0.01)
    
    sigma.p ~ dunif(0, 3)
    tau.p <- pow(sigma.p, -2)
    
    for(i in 1:n.transects){
    for(j in 1:n.surveys){
    delta.p[i,j] ~ dnorm(alpha.p, tau.p)
    }
    }
    
    # Spatial component (kriging)
    W[1:n.transects] ~ dmnorm(muW[], Omega[,]) 
    tauw ~ dgamma(0.001, 0.001)
    w <- 1/sqrt(tauw) # spatial SD
    theta ~ dgamma(0.01, 0.01) # spatial correlation rate
    for (i in 1:n.transects){ 
    for(j in 1:n.transects){
    # H[i, j] <- (1/tauw) * exp(-theta*pow(d[i,j] ,2)) # Spatial covariance matrix
    # H[i, j] <- (1/tauw) * exp(-theta*d[i,j]) # Spatial covariance matrix
    H[i, j] <- (1/tauw) * exp(-d[i,j] / theta) # Spatial covariance matrix
    }
    muW[i] <- 0
    }
    Omega[1:n.transects, 1:n.transects] <- inverse(H[1:n.transects, 1:n.transects]) # spatial precision mat
    
    # Likelihood
    for(i in 1:n.transects){
    N[i] ~ dpois(lambda[i])
    
    log(lambda[i]) <- alpha.lam + beta1.lam*elev[i] + beta3.lam*slope[i] + beta8.lam*ltwi[i] + beta9.lam*canopy[i] + W[i]
    
    for(j in 1:n.surveys){
    C[i, j] ~ dbin(p[i, j], N[i])
    p[i,j] <- 1 / (1 + exp(-lp.lim[i,j]))    
    lp.lim[i,j] <- min(999, max(-999, lp[i,j])) # Help stabilize the logit
    
    lp[i, j] <- beta1.p*Temp.s[i,j] + beta2.p*Temp.s2[i,j] + beta3.p*Precip.s[i,j] + beta4.p*gcover[i] + beta5.p*gcover2[i] + beta10.p*RH.s[i,j] + delta.p[i,j]
    
    # Assess model fit using Chi-squared discrepancy
    # Compute fit statistic for observed data
    eval[i,j] <- p[i,j] * N[i]
    E[i,j] <- pow((C[i,j] - eval[i,j]),2) / (eval[i,j] + 0.5)
    # Generate replicate data and compute fit stats for them
    y.new[i,j] ~ dbin(p[i,j], N[i])
    E.new[i,j] <- pow((y.new[i,j] - eval[i,j]),2) / (eval[i,j] + 0.5) 
    
    diff.cy[i,j] <- C[i,j] - y.new[i,j]
    }
    }
    
    # Derived quantities
    totalN<- sum(N[])
    fit <- sum(E[,])
    fit.new <- sum(E.new[,])
    
    }
    
